# -*- coding: utf-8 -*-
"""EDA(Exploratory data analysis).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KYEQev_Y-SzIeaaDRoc4nd6NhnrtIxI_

# **2. EDA (Exploratory Data Analysis)**
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import silhouette_score
from sklearn.decomposition import PCA
from mpl_toolkits.mplot3d import Axes3D
from scipy.stats import pearsonr

"""Exploration on dataset"""

df = pd.read_csv("gtzan_features.csv",sep=",")
df.describe()

df.columns

df_class = df.groupby("class").size().reset_index(name="count")

fig, axes = plt.subplots(1, 2, figsize=(10, 4))

sns.barplot(x="class", y="count", data=df_class, ax=axes[0])
axes[0].set_title("Amount of songs per class", fontsize=10)
axes[0].set_xlabel("Class", fontsize=12)
axes[0].set_ylabel("Count", fontsize=12)
axes[0].tick_params(axis="x", rotation=45)

axes[1].pie(df_class["count"], labels=df_class["class"], colors=sns.color_palette("viridis"))
axes[1].set_title("Proportion of Songs per Class")

plt.tight_layout()
plt.show()

pip install dcor

import dcor
from sklearn.preprocessing import LabelEncoder

# Convert 'class' to numerical values
label_encoder = LabelEncoder()
df_corr=df.copy()
df_corr['class'] = label_encoder.fit_transform(df_corr['class'])

# Select the MFCC columns and the 'class' column
df_mfcc = df_corr[['mfcc_1', 'mfcc_2', 'mfcc_3', 'mfcc_4', 'mfcc_5',
              'mfcc_6', 'mfcc_7', 'mfcc_8', 'mfcc_9', 'mfcc_10', 'mfcc_11', 'class']]

# Pearson and Spearman correlation
pearson_corr = df_mfcc.corr(method="pearson")["class"].drop("class")
spearman_corr = df_mfcc.corr(method="spearman")["class"].drop("class")

# Calculate the Distance Correlation for each feature with 'class'
distance_corr = {col: dcor.distance_correlation(df_mfcc["class"], df_mfcc[col]) for col in df_mfcc.columns if col != "class"}
distance_corr = pd.Series(distance_corr)

# Combine results into a DataFrame
df_corr = pd.DataFrame({
    "Pearson": pearson_corr,
    "Spearman": spearman_corr,
    "Distance Correlation": distance_corr
}).sort_values(by="Distance Correlation", ascending=False)

# Plot
plt.figure(figsize=(10, 6))
sns.heatmap(df_corr, annot=True, cmap="coolwarm", center=0, fmt=".3f", linewidths=0.5)
plt.title("Comparison of diferent correlations with class", fontsize=14, fontweight="bold")
plt.show()

import dcor
from sklearn.preprocessing import LabelEncoder

# Convert 'class' to numerical values
label_encoder = LabelEncoder()
df_corr=df.copy()
df_corr['class'] = label_encoder.fit_transform(df_corr['class'])

# Select the MFCC columns and the 'class' column
df_spectral = df_corr[['spectral_contrast_1', 'spectral_contrast_2',
       'spectral_contrast_3', 'spectral_contrast_4', 'spectral_contrast_5',
       'spectral_contrast_6', 'spectral_contrast_7', 'class']]

# Pearson and Spearman correlation
pearson_corr = df_spectral.corr(method="pearson")["class"].drop("class")
spearman_corr = df_spectral.corr(method="spearman")["class"].drop("class")

# Calculate the Distance Correlation for each feature with 'class'
distance_corr = {col: dcor.distance_correlation(df_spectral["class"], df_spectral[col]) for col in df_spectral.columns if col != "class"}
distance_corr = pd.Series(distance_corr)

# Combine results into a DataFrame
df_corr = pd.DataFrame({
    "Pearson": pearson_corr,
    "Spearman": spearman_corr,
    "Distance Correlation": distance_corr
}).sort_values(by="Distance Correlation", ascending=False)

# Plot
plt.figure(figsize=(10, 6))
sns.heatmap(df_corr, annot=True, cmap="coolwarm", center=0, fmt=".3f", linewidths=0.5)
plt.title("Comparison of diferent correlations with class", fontsize=14, fontweight="bold")
plt.show()

# Set the style for the plots
sns.set_style("whitegrid")

# Create a figure with 2 subplots (one above the other)
fig, axes = plt.subplots(2, 1, figsize=(10, 6))  # 2 rows, 1 column

# First Boxplot for 'mfcc_2'
sns.boxplot(
    x='class',
    y='mfcc_2',
    data=df,
    palette='viridis',
    ax=axes[0]  # Assigning this plot to the first subplot
)

axes[0].set_title('Distribution of feature mfcc_2', fontsize=12, fontweight='bold')
axes[0].set_xlabel('Class', fontsize=10)
axes[0].set_ylabel('MFCC_2', fontsize=10)
axes[0].tick_params(axis='x', labelsize=9)  # Adjust x-axis tick labels size
axes[0].tick_params(axis='y', labelsize=9)  # Adjust y-axis tick labels size

# Second Boxplot for 'mfcc_1'
sns.boxplot(
    x='class',
    y='mfcc_1',
    data=df,
    palette='viridis',
    ax=axes[1]  # Assigning this plot to the second subplot
)

axes[1].set_title('Distribution of feature mfcc_1', fontsize=12, fontweight='bold')
axes[1].set_xlabel('Class', fontsize=10)
axes[1].set_ylabel('MFCC_1', fontsize=10)
axes[1].tick_params(axis='x', labelsize=9)  # Adjust x-axis tick labels size
axes[1].tick_params(axis='y', labelsize=9)  # Adjust y-axis tick labels size

# Automatically adjust layout to prevent overlap
plt.tight_layout()

# Show the plot
plt.show()